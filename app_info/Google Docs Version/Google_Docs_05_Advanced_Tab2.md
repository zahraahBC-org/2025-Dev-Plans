# TAB 2: Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© | Advanced Error Management

## 22. Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
### Advanced Error Management

---

## ğŸ¯ **Ø§Ù„Ù‡Ø¯Ù | Objective**
ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø£Ø®Ø·Ø§Ø¡ Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ø´Ø§Ù…Ù„Ø© ÙˆØ§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ø³ØªØ±Ø¯Ø§Ø¯ ÙˆØªØ­Ø³ÙŠÙ† ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ØªØ·Ø¨ÙŠÙ‚ Flutter Ù„Ù„ØªØ¬Ø§Ø±Ø© Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©.

## ğŸ“‹ **Rule | Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©**
**Arabic**: Ø¥Ø¯Ø§Ø±Ø© Ø£Ø®Ø·Ø§Ø¡ Ù…ØªÙ‚Ø¯Ù…Ø© + Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø© + ØªØ­Ø³ÙŠÙ† ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… + Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡  
**English**: Advanced error management + recovery strategies + UX optimization + error monitoring

## ğŸ’¡ **Benefits | Ø§Ù„ÙÙˆØ§Ø¦Ø¯**
- **Robust Error Handling | Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ù‚ÙˆÙŠØ©**: Comprehensive error handling across all layers
- **User Experience | ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…**: Graceful error recovery and user-friendly messages
- **System Reliability | Ù…ÙˆØ«ÙˆÙ‚ÙŠØ© Ø§Ù„Ù†Ø¸Ø§Ù…**: Proactive error prevention and recovery
- **Developer Productivity | Ø¥Ù†ØªØ§Ø¬ÙŠØ© Ø§Ù„Ù…Ø·ÙˆØ±**: Clear error reporting and debugging tools
- **Business Continuity | Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© Ø§Ù„Ø£Ø¹Ù…Ø§Ù„**: Minimize business impact of errors
- **Data Integrity | Ø³Ù„Ø§Ù…Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª**: Ensure data consistency during errors

## ğŸ› ï¸ **Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ | Implementation**
- **Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ**: Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø±Ø¶Ø© Ù„Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆØ§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ¬Ø§Ø±ÙŠ Ø§Ù„Ø­Ø±Ø¬
- **ÙƒÙŠÙÙŠØ© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚**:
  - ØªØ·Ø¨ÙŠÙ‚ Ø£Ù†Ù…Ø§Ø· Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ø´Ø§Ù…Ù„Ø©
  - Ø¥Ø¶Ø§ÙØ© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
  - Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ø¦Ù„ Ø®Ø·Ø£ ÙˆØ¯ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
  - Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø§Ù‚Ø¨Ø© ÙˆØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
  - ØªØ·Ø¨ÙŠÙ‚ ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- **Ø§Ù„Ù†ØªÙŠØ¬Ø©**: Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø£Ø®Ø·Ø§Ø¡ Ù‚ÙˆÙŠ ÙˆÙˆØ¯ÙˆØ¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…

## ğŸ¯ **Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© | Specific Priorities**

### **Ø£ÙˆÙ„ÙˆÙŠØ§Øª Ø®Ø§ØµØ© Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© | Advanced Error Management Specific Priorities:**
#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: Ø§Ù„Ø£Ø³Ø§Ø³ | Phase 1: Foundation**
- **ğŸ”´ Ø­Ø±Ø¬**: ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ø´Ø§Ù…Ù„Ø©
- **ğŸ”´ Ø­Ø±Ø¬**: Ø¥Ø¶Ø§ÙØ© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- **ğŸŸ  Ø¹Ø§Ù„ÙŠ**: Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ø¦Ù„ Ø®Ø·Ø£ ÙˆØ¯ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: Ø§Ù„ØªØ­Ø³ÙŠÙ† | Phase 2: Enhancement**
- **ğŸŸ  Ø¹Ø§Ù„ÙŠ**: Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø§Ù‚Ø¨Ø© ÙˆØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- **ğŸŸ  Ø¹Ø§Ù„ÙŠ**: ØªØ·Ø¨ÙŠÙ‚ ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- **ğŸŸ¡ Ù…ØªÙˆØ³Ø·**: Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø¹ Ø£Ø®Ø·Ø§Ø¡ Ù…ØªÙ‚Ø¯Ù…

#### **Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©: Ø§Ù„ØªØ­Ø³ÙŠÙ† | Phase 3: Optimization**
- **ğŸŸ¡ Ù…ØªÙˆØ³Ø·**: Ø¢Ù„ÙŠØ§Øª Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø£Ø®Ø·Ø§Ø¡ Ù…ØªÙ‚Ø¯Ù…Ø©
- **ğŸŸ¡ Ù…ØªÙˆØ³Ø·**: Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ù…Ø¯Ø¹ÙˆÙ… Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
- **ğŸŸ¢ Ù…Ù†Ø®ÙØ¶**: Ù…Ù†Ø¹ Ø£Ø®Ø·Ø§Ø¡ ØªÙ†Ø¨Ø¤ÙŠ

## ğŸ“ˆ **Success Metrics | Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù†Ø¬Ø§Ø­**

### **Ù…Ù‚Ø§ÙŠÙŠØ³ Ø®Ø§ØµØ© Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© | Advanced Error Management Specific Metrics:**
- **Ù…Ø¹Ø¯Ù„ Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ | Error Recovery Rate**: >95% successful recovery
- **ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… | User Experience**: <2% user complaints about errors
- **Ù…ÙˆØ«ÙˆÙ‚ÙŠØ© Ø§Ù„Ù†Ø¸Ø§Ù… | System Reliability**: >99.9% uptime
- **ÙˆÙ‚Øª Ø­Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ | Error Resolution Time**: <5 minutes average
- **Ø³Ù„Ø§Ù…Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª | Data Integrity**: 100% data consistency
- **Ù…Ù†Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ | Error Prevention**: >80% error prevention rate

## âš ï¸ **Common Pitfalls & Best Practices | Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© ÙˆØ£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª**

### **Ø£Ø®Ø·Ø§Ø¡ Ø´Ø§Ø¦Ø¹Ø© Ø®Ø§ØµØ© Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© | Advanced Error Management Specific Pitfalls:**
- **ØªØ¬Ù†Ø¨ | Avoid**: Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©
- **ØªØ¬Ù†Ø¨ | Avoid**: Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø£Ø®Ø·Ø§Ø¡ Ø¶Ø¹ÙŠÙØ©
- **ØªØ¬Ù†Ø¨ | Avoid**: Ø±Ø³Ø§Ø¦Ù„ Ø®Ø·Ø£ ØºÙŠØ± ÙˆØ§Ø¶Ø­Ø©
- **ØªØ¬Ù†Ø¨ | Avoid**: Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- **ØªØ¬Ù†Ø¨ | Avoid**: ØªØ­Ù„ÙŠÙ„Ø§Øª Ø£Ø®Ø·Ø§Ø¡ ØºÙŠØ± ÙƒØ§ÙÙŠØ©

### **Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª | Best Practices:**
- **Ø§Ø³ØªØ®Ø¯Ù… | Use**: Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ø´Ø§Ù…Ù„Ø©
- **Ø§Ø³ØªØ®Ø¯Ù… | Use**: Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø£Ø®Ø·Ø§Ø¡ Ù‚ÙˆÙŠØ©
- **Ø§Ø³ØªØ®Ø¯Ù… | Use**: Ø±Ø³Ø§Ø¦Ù„ Ø®Ø·Ø£ ÙˆØ§Ø¶Ø­Ø© ÙˆÙˆØ¯ÙˆØ¯Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
- **Ø§Ø³ØªØ®Ø¯Ù… | Use**: Ù…Ø±Ø§Ù‚Ø¨Ø© Ø£Ø®Ø·Ø§Ø¡ Ù…ÙƒØªÙ…Ù„Ø©
- **Ø§Ø³ØªØ®Ø¯Ù… | Use**: ØªØ­Ù„ÙŠÙ„Ø§Øª Ø£Ø®Ø·Ø§Ø¡ Ù…ÙØµÙ„Ø©

## ğŸ›¡ï¸ **Error Handling Patterns | Ø£Ù†Ù…Ø§Ø· Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**

### **1. Error Handler Service | Ø®Ø¯Ù…Ø© Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**
```dart
// lib/core/error_handling/error_handler_service.dart
class ErrorHandlerService {
  static final Map<Type, ErrorHandler> _handlers = {};
  static final List<ErrorInterceptor> _interceptors = [];
  
  static void initialize() {
    _registerDefaultHandlers();
    _registerInterceptors();
  }
  
  static void _registerDefaultHandlers() {
    _handlers[NetworkException] = NetworkErrorHandler();
    _handlers[ValidationException] = ValidationErrorHandler();
    _handlers[AuthenticationException] = AuthenticationErrorHandler();
    _handlers[BusinessException] = BusinessErrorHandler();
    _handlers[SystemException] = SystemErrorHandler();
  }
  
  static void _registerInterceptors() {
    _interceptors.add(ErrorLoggingInterceptor());
    _interceptors.add(ErrorAnalyticsInterceptor());
    _interceptors.add(ErrorNotificationInterceptor());
  }
  
  static Future<void> handleError(
    dynamic error,
    StackTrace? stackTrace, {
    String? context,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      // Run interceptors
      for (final interceptor in _interceptors) {
        await interceptor.onError(error, stackTrace, context: context, metadata: metadata);
      }
      
      // Find appropriate handler
      final handler = _findHandler(error);
      if (handler != null) {
        await handler.handle(error, stackTrace, context: context, metadata: metadata);
      } else {
        await _handleUnknownError(error, stackTrace, context: context, metadata: metadata);
      }
    } catch (e) {
      // Fallback error handling
      await _handleFallbackError(e, error, stackTrace, context: context, metadata: metadata);
    }
  }
  
  static ErrorHandler? _findHandler(dynamic error) {
    for (final entry in _handlers.entries) {
      if (error.runtimeType == entry.key) {
        return entry.value;
      }
    }
    return null;
  }
  
  static Future<void> _handleUnknownError(
    dynamic error,
    StackTrace? stackTrace, {
    String? context,
    Map<String, dynamic>? metadata,
  }) async {
    await ErrorLoggingService.logError(
      error: error,
      stackTrace: stackTrace,
      context: context ?? 'unknown_error',
      metadata: metadata ?? {},
    );
    
    await ErrorNotificationService.showError(
      title: 'Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹',
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.',
    );
  }
  
  static Future<void> _handleFallbackError(
    dynamic fallbackError,
    dynamic originalError,
    StackTrace? stackTrace, {
    String? context,
    Map<String, dynamic>? metadata,
  }) async {
    // Log both errors
    await ErrorLoggingService.logError(
      error: fallbackError,
      stackTrace: stackTrace,
      context: 'fallback_error',
      metadata: {
        'original_error': originalError.toString(),
        'original_context': context,
        'original_metadata': metadata ?? {},
      },
    );
  }
}

abstract class ErrorHandler {
  Future<void> handle(
    dynamic error,
    StackTrace? stackTrace, {
    String? context,
    Map<String, dynamic>? metadata,
  });
}

abstract class ErrorInterceptor {
  Future<void> onError(
    dynamic error,
    StackTrace? stackTrace, {
    String? context,
    Map<String, dynamic>? metadata,
  });
}
```

### **2. Error Types | Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**
```dart
// lib/core/error_handling/error_types.dart
abstract class AppException implements Exception {
  final String message;
  final String? code;
  final Map<String, dynamic>? metadata;
  final DateTime timestamp;
  
  AppException({
    required this.message,
    this.code,
    this.metadata,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? DateTime.now();
  
  @override
  String toString() => '${runtimeType}: $message';
}

class NetworkException extends AppException {
  NetworkException({
    required String message,
    String? code,
    Map<String, dynamic>? metadata,
  }) : super(message: message, code: code, metadata: metadata);
}

class ValidationException extends AppException {
  ValidationException({
    required String message,
    String? code,
    Map<String, dynamic>? metadata,
  }) : super(message: message, code: code, metadata: metadata);
}

class AuthenticationException extends AppException {
  AuthenticationException({
    required String message,
    String? code,
    Map<String, dynamic>? metadata,
  }) : super(message: message, code: code, metadata: metadata);
}

class BusinessException extends AppException {
  BusinessException({
    required String message,
    String? code,
    Map<String, dynamic>? metadata,
  }) : super(message: message, code: code, metadata: metadata);
}

class SystemException extends AppException {
  SystemException({
    required String message,
    String? code,
    Map<String, dynamic>? metadata,
  }) : super(message: message, code: code, metadata: metadata);
}
```

## ğŸ”„ **Error Recovery Strategies | Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**

### **1. Retry Mechanism | Ø¢Ù„ÙŠØ© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©**
```dart
// lib/core/error_handling/retry_mechanism.dart
class RetryMechanism {
  static Future<T> executeWithRetry<T>(
    Future<T> Function() operation, {
    int maxRetries = 3,
    Duration initialDelay = const Duration(seconds: 1),
    double backoffMultiplier = 2.0,
    bool Function(dynamic error)? shouldRetry,
  }) async {
    int attempts = 0;
    Duration delay = initialDelay;
    
    while (attempts < maxRetries) {
      try {
        return await operation();
      } catch (error) {
        attempts++;
        
        if (attempts >= maxRetries) {
          throw error;
        }
        
        if (shouldRetry != null && !shouldRetry(error)) {
          throw error;
        }
        
        await Future.delayed(delay);
        delay = Duration(milliseconds: (delay.inMilliseconds * backoffMultiplier).round());
      }
    }
    
    throw Exception('Max retries exceeded');
  }
  
  static bool defaultShouldRetry(dynamic error) {
    if (error is NetworkException) {
      return true;
    }
    if (error is SystemException) {
      return true;
    }
    return false;
  }
}
```

### **2. Circuit Breaker | Ù‚Ø§Ø·Ø¹ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©**
```dart
// lib/core/error_handling/circuit_breaker.dart
class CircuitBreaker {
  final String name;
  final int failureThreshold;
  final Duration timeout;
  final Duration resetTimeout;
  
  CircuitState _state = CircuitState.closed;
  int _failureCount = 0;
  DateTime? _lastFailureTime;
  DateTime? _nextAttemptTime;
  
  CircuitBreaker({
    required this.name,
    required this.failureThreshold,
    required this.timeout,
    required this.resetTimeout,
  });
  
  Future<T> execute<T>(Future<T> Function() operation) async {
    if (_state == CircuitState.open) {
      if (_nextAttemptTime != null && DateTime.now().isBefore(_nextAttemptTime!)) {
        throw CircuitBreakerOpenException('Circuit breaker is open');
      }
      _state = CircuitState.halfOpen;
    }
    
    try {
      final result = await operation().timeout(timeout);
      _onSuccess();
      return result;
    } catch (error) {
      _onFailure();
      throw error;
    }
  }
  
  void _onSuccess() {
    _failureCount = 0;
    _state = CircuitState.closed;
    _lastFailureTime = null;
    _nextAttemptTime = null;
  }
  
  void _onFailure() {
    _failureCount++;
    _lastFailureTime = DateTime.now();
    
    if (_failureCount >= failureThreshold) {
      _state = CircuitState.open;
      _nextAttemptTime = DateTime.now().add(resetTimeout);
    }
  }
  
  CircuitState get state => _state;
  int get failureCount => _failureCount;
}

enum CircuitState {
  closed,
  open,
  halfOpen,
}

class CircuitBreakerOpenException implements Exception {
  final String message;
  CircuitBreakerOpenException(this.message);
  
  @override
  String toString() => 'CircuitBreakerOpenException: $message';
}
```

### **3. Error Recovery Widget | Ø¹Ù†ØµØ± Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**
```dart
// lib/core/error_handling/error_recovery_widget.dart
class ErrorRecoveryWidget extends StatefulWidget {
  final Widget child;
  final Future<void> Function()? onRetry;
  final Widget? errorWidget;
  final Duration retryDelay;
  
  const ErrorRecoveryWidget({
    super.key,
    required this.child,
    this.onRetry,
    this.errorWidget,
    this.retryDelay = const Duration(seconds: 2),
  });
  
  @override
  State<ErrorRecoveryWidget> createState() => _ErrorRecoveryWidgetState();
}

class _ErrorRecoveryWidgetState extends State<ErrorRecoveryWidget> {
  bool _hasError = false;
  dynamic _error;
  
  @override
  Widget build(BuildContext context) {
    if (_hasError) {
      return widget.errorWidget ?? _buildDefaultErrorWidget();
    }
    
    return widget.child;
  }
  
  Widget _buildDefaultErrorWidget() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.error_outline,
            size: 64,
            color: Colors.red,
          ),
          const SizedBox(height: 16),
          const Text(
            'Ø­Ø¯Ø« Ø®Ø·Ø£',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          Text(
            _error?.toString() ?? 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ',
            textAlign: TextAlign.center,
            style: const TextStyle(fontSize: 14, color: Colors.grey),
          ),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: _retry,
            child: const Text('Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©'),
          ),
        ],
      ),
    );
  }
  
  void _retry() async {
    setState(() {
      _hasError = false;
      _error = null;
    });
    
    if (widget.onRetry != null) {
      try {
        await widget.onRetry!();
      } catch (e) {
        setState(() {
          _hasError = true;
          _error = e;
        });
      }
    }
  }
  
  void _handleError(dynamic error) {
    setState(() {
      _hasError = true;
      _error = error;
    });
  }
}
```

## ğŸ“Š **Error Monitoring | Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**

### **1. Error Monitoring Service | Ø®Ø¯Ù…Ø© Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**
```dart
// lib/core/error_handling/error_monitoring_service.dart
class ErrorMonitoringService {
  static final List<ErrorMonitor> _monitors = [];
  
  static void initialize() {
    _monitors.add(CrashlyticsMonitor());
    _monitors.add(SentryMonitor());
    _monitors.add(CustomErrorMonitor());
  }
  
  static Future<void> reportError(
    dynamic error,
    StackTrace? stackTrace, {
    String? context,
    Map<String, dynamic>? metadata,
  }) async {
    for (final monitor in _monitors) {
      try {
        await monitor.reportError(
          error: error,
          stackTrace: stackTrace,
          context: context,
          metadata: metadata,
        );
      } catch (e) {
        // Don't let monitoring errors affect the app
        print('Error monitoring failed: $e');
      }
    }
  }
  
  static Future<void> reportCustomEvent(
    String eventName,
    Map<String, dynamic>? metadata,
  ) async {
    for (final monitor in _monitors) {
      try {
        await monitor.reportCustomEvent(eventName, metadata);
      } catch (e) {
        print('Custom event reporting failed: $e');
      }
    }
  }
}

abstract class ErrorMonitor {
  Future<void> reportError({
    required dynamic error,
    StackTrace? stackTrace,
    String? context,
    Map<String, dynamic>? metadata,
  });
  
  Future<void> reportCustomEvent(
    String eventName,
    Map<String, dynamic>? metadata,
  );
}

class CrashlyticsMonitor implements ErrorMonitor {
  @override
  Future<void> reportError({
    required dynamic error,
    StackTrace? stackTrace,
    String? context,
    Map<String, dynamic>? metadata,
  }) async {
    await FirebaseCrashlytics.instance.recordError(
      error,
      stackTrace,
      reason: context,
      information: metadata?.entries.map((e) => DiagnosticsProperty(e.key, e.value)).toList(),
    );
  }
  
  @override
  Future<void> reportCustomEvent(
    String eventName,
    Map<String, dynamic>? metadata,
  ) async {
    await FirebaseCrashlytics.instance.log('$eventName: $metadata');
  }
}

class SentryMonitor implements ErrorMonitor {
  @override
  Future<void> reportError({
    required dynamic error,
    StackTrace? stackTrace,
    String? context,
    Map<String, dynamic>? metadata,
  }) async {
    await Sentry.captureException(
      error,
      stackTrace: stackTrace,
      withScope: (scope) {
        scope.setTag('context', context ?? 'unknown');
        if (metadata != null) {
          scope.setContexts('metadata', metadata);
        }
      },
    );
  }
  
  @override
  Future<void> reportCustomEvent(
    String eventName,
    Map<String, dynamic>? metadata,
  ) async {
    await Sentry.addBreadcrumb(
      Breadcrumb(
        message: eventName,
        data: metadata,
        level: SentryLevel.info,
      ),
    );
  }
}

class CustomErrorMonitor implements ErrorMonitor {
  @override
  Future<void> reportError({
    required dynamic error,
    StackTrace? stackTrace,
    String? context,
    Map<String, dynamic>? metadata,
  }) async {
    // Custom error reporting logic
    await _sendToCustomEndpoint(error, stackTrace, context, metadata);
  }
  
  @override
  Future<void> reportCustomEvent(
    String eventName,
    Map<String, dynamic>? metadata,
  ) async {
    // Custom event reporting logic
    await _sendCustomEventToEndpoint(eventName, metadata);
  }
  
  Future<void> _sendToCustomEndpoint(
    dynamic error,
    StackTrace? stackTrace,
    String? context,
    Map<String, dynamic>? metadata,
  ) async {
    // Implementation for custom error endpoint
  }
  
  Future<void> _sendCustomEventToEndpoint(
    String eventName,
    Map<String, dynamic>? metadata,
  ) async {
    // Implementation for custom event endpoint
  }
}
```

## ğŸ“ˆ **Error Analytics | ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**

### **1. Error Analytics Service | Ø®Ø¯Ù…Ø© ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø®Ø·Ø§Ø¡**
```dart
// lib/core/error_handling/error_analytics_service.dart
class ErrorAnalyticsService {
  static Future<void> trackError(
    dynamic error,
    String? context, {
    Map<String, dynamic>? metadata,
  }) async {
    await FirebaseAnalyticsService.logEvent('error_occurred', {
      'error_type': error.runtimeType.toString(),
      'error_message': error.toString(),
      'context': context ?? 'unknown',
      'metadata': metadata ?? {},
      'timestamp': DateTime.now().toIso8601String(),
    });
  }
  
  static Future<void> trackErrorRecovery(
    String recoveryMethod,
    bool success, {
    Map<String, dynamic>? metadata,
  }) async {
    await FirebaseAnalyticsService.logEvent('error_recovery', {
      'recovery_method': recoveryMethod,
      'success': success,
      'metadata': metadata ?? {},
      'timestamp': DateTime.now().toIso8601String(),
    });
  }
  
  static Future<void> trackErrorResolution(
    String resolutionMethod,
    Duration resolutionTime, {
    Map<String, dynamic>? metadata,
  }) async {
    await FirebaseAnalyticsService.logEvent('error_resolution', {
      'resolution_method': resolutionMethod,
      'resolution_time_ms': resolutionTime.inMilliseconds,
      'metadata': metadata ?? {},
      'timestamp': DateTime.now().toIso8601String(),
    });
  }
  
  static Future<void> trackUserErrorExperience(
    String errorType,
    String userAction, {
    Map<String, dynamic>? metadata,
  }) async {
    await FirebaseAnalyticsService.logEvent('user_error_experience', {
      'error_type': errorType,
      'user_action': userAction,
      'metadata': metadata ?? {},
      'timestamp': DateTime.now().toIso8601String(),
    });
  }
}
```

## ğŸ“‹ **Implementation Checklist | Ù‚Ø§Ø¦Ù…Ø© Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ØªÙ†ÙÙŠØ°**

### **1. Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ | Error Handling**
- [ ] ØªØ·Ø¨ÙŠÙ‚ Ø®Ø¯Ù…Ø© Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] Ø¥Ø¶Ø§ÙØ© Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆØ§Ù„Ø§Ø³ØªØ«Ù†Ø§Ø¡Ø§Øª
- [ ] Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ù†Ù…Ø§Ø· Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ¸Ø§Ø¦Ù Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

### **2. Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ | Error Recovery**
- [ ] ØªØ·Ø¨ÙŠÙ‚ Ø¢Ù„ÙŠØ© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
- [ ] Ø¥Ø¶Ø§ÙØ© Ù†Ù…Ø· Circuit Breaker
- [ ] Ø¥Ù†Ø´Ø§Ø¡ ÙˆÙŠØ¯Ø¬Øª Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] Ø§Ø®ØªØ¨Ø§Ø± Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

### **3. Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ | Error Monitoring**
- [ ] Ø¥Ø¹Ø¯Ø§Ø¯ Ø®Ø¯Ù…Ø© Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] Ø¥Ø¶Ø§ÙØ© ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø£Ø¹Ø·Ø§Ù„
- [ ] ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø£Ø®Ø·Ø§Ø¡ Ù…Ø®ØµØµØ©
- [ ] Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ¸Ø§Ø¦Ù Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

### **4. ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ | Error Analytics**
- [ ] Ø¥Ø¶Ø§ÙØ© ØªØªØ¨Ø¹ ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] ØªØ·Ø¨ÙŠÙ‚ ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ¸Ø§Ø¦Ù ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

### **5. ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… | User Experience**
- [ ] Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ø¦Ù„ Ø®Ø·Ø£ ÙˆØ¯ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
- [ ] Ø¥Ø¶Ø§ÙØ© ÙˆØ§Ø¬Ù‡Ø© Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] ØªØ·Ø¨ÙŠÙ‚ Ù…Ù†Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
- [ ] Ø§Ø®ØªØ¨Ø§Ø± ØªØ­Ø³ÙŠÙ†Ø§Øª ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…

---

**Next Tab**: Monitoring & Alerting | Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© ÙˆØ§Ù„ØªÙ†Ø¨ÙŠÙ‡
